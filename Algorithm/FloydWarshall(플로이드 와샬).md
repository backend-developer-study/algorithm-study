# 내용 구성 📖
> 사용할 알고리즘 : 플로이드 와샬(Floyd Warshall Algorithm)  
> 응용분야 : 모든 정점의 최단경로  
> 같이 알아보면 좋은 알고리즘 : 다익스트라 알고리즘  


# 플로이드 와샬 알고리즘이란? 
 - `모든 정점`에서 `모든 정점`으로의 최단 경로를 구하는 알고리즘
 - 거쳐가는 정점을 기준으로 알고리즘을 수행한다.
 - 다익스트라 알고리즘과는 다르게 음의 간선도 사용할 수 있다. 
 - 모든 정점(노드)간의 최단거리를 구해야하므로 2차원 인접행렬로 구성해야한다. 
 - 내가 원하는 도시(지점)까지 가는 최단 비용 혹은 경로를 구하기 좋다.
> 다시한번 정리하자면   
> 노드 = 정점 = 도시  
> 간선 = 거리 = 비용

<br></br>
<br></br>

## 예시 상황
> 보다 좋은 이해를 위해 예시상황을 만들어 보자

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190905606-fab819dd-1fc8-4c74-9e9d-58a577eab8e5.png" width="70%"></p>

- 그림과 같이 총 6개의 정점(노드)가 있고, 비용이 적힌 9개의 간선이 있다.
- 이제 하나씩 거쳐가면서 최단거리를 구해보자

<br></br>


### 정점과 간선을 2차원 인접행렬로 정렬

- 정점의 개수가 6개 임으로, 6 X 6 인접행렬이 나온다. 
- 또한, 현재 정점(노드)에서 현재 정점(노드)로 가는 비용은 0임으로 0으로 채워넣는다.
- 맨처음을 (1,1)로 보고 그 다음을 (1,2)로 본다고 했을때, 1에서 2로 가는 비용을 말하는데, 초기에는 갈수있는 방법을 알수 없으므로 무한으로 둘 수 있다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190910016-09b75cf8-59a2-410a-be5f-683f1a2e23fb.png" width="70%"></p>
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190909134-93697bc5-9a69-4c6c-9182-79590b22366e.png" width="70%"></p>

- 이런식으로 6번 정점(노드)까지 채운다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190910570-f912b69f-d909-4bcb-8ecb-d70e35fc308e.png" width="70%"></p>

<br></br>

## 정점(노드)1을 거쳐가는 경우
 - 2차원 인접행렬`[i,j]`에서 `i`정점에서 `j`정점까지 가는데 , 1번 정점을 거쳐서 가능 경우를 계산하는 것이다.
    - 예를 들어 `[2,3]`은 원래 `2`정점에서 `3`정점으로 가는 비용만 적혀있지만, `2`->`1`->`3`의 비용이랑 비교하여, 작은 값을 넣게 되는 것이다.
    - 시작점이나, 끝나는 지점이 1이거나 1이 포함될 수 없는 곳은 포함하지 않았다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190910785-9483e073-edce-474e-8dea-6473a30104e6.png" width="70%"></p>


#### 2는 1를 거칠 수 없으니, 정점 3을 예로 들어 보겠다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190911093-a761c21c-a320-447b-a2c2-6d19aa394a3d.png" width="70%"></p>

- `3` -> `2` 로 가는 경우, 원래 비용은 `22`이다. 
  - `3` -> `1` -> `2`의 비용을 계산하게되면, 41 + `INF` = `INF`이다.
  - `22`가 `INF` 보다 작으므로 원래 값인 `22`가 있는다.

<br></br>

- `3` -> `4`로 가는 경우, 원래 비용은 `INF`였다.
  - 하지만, `3` -> `1` -> `4` 로 가는 비용은, `3` -> `1` 로 가는 비용 `41`과  `1`-> `4`로 가는 비용 `10`을 합하면, `51`이 나온다. 
  - `INF` 보다 `51`이 더 작으므로, `[3,4]` 자리에는 `51`이 들어가게 된다.

<br></br>
- `3`-> `5`로 가는 경우 `24`였다.
  - `3` -> `1` 비용 41 +  `1` -> `5` 비용 24 = 65
  - 65 > 24  ==> 24 그대로
<br></br>
- `3` -> `6`으로 가는 경우, `INF`였다.
  - `3` -> `1` 비용 41 +  `1` -> `6` 비용 25 = 66
  - `INF` > 66  ==> 66 으로 바뀐다.

<br></br>
 - 이런 식으로 노드가 1일 경우를 순환해주면, 아래와 같이 채워진다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190911621-95db14b9-10d4-4ccf-bd18-264bfa7c0cee.png" width="70%"></p>

## 정점 6번까지 거쳐서 가는 경우 반복
 - 여기서 한가지 의문이 들수 있다. 그럼 하나의 정점만 거쳐서 들리고, 2개의 정점을 거쳐서 가야되는 경우는 계산이 안되는 것 아니냐? 
    - 이것의 해답은 2차원 인접행렬이라는 점과 정점6번까지 반복하면 나온다.
 - 위의 예시는 정점과 정점 사이의 간선 비용이 양방향다 같은 값이다. 그래서 [4,2]와 [2,4]가 같은 값으로 나타나지만, 만약 다른 값이라면 행렬의 결과값도 다를 것이다. 
 - 그리고 애초에 [4,5]로 가는 비용이 , `4` -> `1` -> `5`로 최단 거리로 치환되었기 때문에, 만약 [4,6]으로 가는 비용이 `5`를 거쳐서 간다고 하면, 결국 `4` -> `1` -> `5`->`6`와 같은 셈이다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/190912438-36e0c9c5-422d-41fd-989c-a4f842c91f3c.png" width="70%"></p>


<br></br>
<br></br>



# 코드로 짜보기 
 - 여기서, Integer.MAX_VALUE 를 사용하지 않은 이유는, `Integer.MAX_VALUE + 1` 만 해도 음수로 넘어가기 때문이다. 
```java
public class FloydWarshall {

    static int[][] map = {
            {0, 12345, 41, 10,24,25},
            {12345, 0 ,22, 66, 12345, 12345},
            {41, 22 , 0 , 12345, 24, 12345},
            {10, 66, 12345, 0, 12345, 50},
            {24, 12345, 24, 12345, 0, 12345,2},
            {25, 12345, 12345, 50, 2 ,0}
    };
    static int[][] result = new int[6][6];
    public static void main(String[] args) {
        floydWarshall();
        //결과 출력
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map.length; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }    
    
    public static void floydWarshall(){
        // 결과를 초기화한다.

        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map.length; j++) {
                result[i][j] = map[i][j];
            }
        }
        // 거쳐가는 정점
        for (int k = 0; k < map.length; k++) {
            // 출발하는 정점
            for (int i = 0; i <map.length ; i++) {
                // 도착하는 정점
                for (int j = 0; j < map.length; j++) {
                    if(result[i][j] > result[i][k] + result[k][j]){
                        result[i][j] = result[i][k] + result[k][j];
                    }
                }
            }
        }
    }
    
}
```
### 결과 창
```java
0 63 41 10 24 25 
63 0 22 66 46 88 
41 22 0 51 24 66 
10 66 51 0 34 35 
24 46 24 34 0 49 
25 48 26 35 2 0 
```
- 2차원 인접행렬에서 0을 중심으로 아래쪽에 위치한 값들이 정확하다는 것을 알 수 있다.


