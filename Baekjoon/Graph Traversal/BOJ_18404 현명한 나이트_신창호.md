
# ë¬¸ì œ êµ¬ì„± ğŸ“–
> ì½”ë”©í…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸ : ë°±ì¤€  
> ë‚œì´ë„ : ì‹¤ë²„1     
> í’€ì´ ë‚ ì§œ : 2022.08.26  
> ì‚¬ìš©í•œ í’€ì´ ë°©ë²• : BFS   
> ì†Œìš”ì‹œê°„ : ì•½ 1ì‹œê°„?(ë‹¤ë¥¸ ì¼ì •ì´ ê²¹ì³ ë„ˆë¬´ ë„ì—„ë„ì—„ í’ˆ)  
## ë¬¸ì œë§í¬
https://www.acmicpc.net/problem/18404


<br></br>
<br></br>

## ì‚½ì§ˆì½”ë”©
### í’€ì´
> ë‚˜ì´íŠ¸ ë§ ìœ„ì¹˜ì—ì„œ ìƒëŒ€í¸ ë§ë“¤ì˜ ìµœì†Œì´ë™ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œ  
>  ëª¨ë‘ ì¡ëŠ” ìµœì†Œê°’ì´ ì•„ë‹Œ, ê°ê°ì˜ ìµœì†Œê°’ì´ì—¬ì„œ, BFSë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ê° ì ìš©í•˜ë©´ ë  ê²ƒ ê°™ì•„ ë³´ì¸ë‹¤.

<br></br>

### ê³ ë¯¼í•œì  
> ë‚˜ì´íŠ¸ê°€ ìƒëŒ€ë°© ë§ê¹Œì§€ëŠ” ì´ë™íšŸìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì˜ í° í‹€ì€ ê·¸ë˜í”„íƒìƒ‰ì´ì§€ë§Œ, 
> ê·¸ë˜í”„íƒìƒ‰ì„ ì–´ë–»ê²Œ í• ì§€ì— ëŒ€í•´ì„œëŠ” ì—¬ëŸ¬ê°€ì§€ ìƒê°í–ˆì—ˆë‹¤.

- ê·¸ë˜í”„íƒìƒ‰ DFSì™€ BFSì¤‘ì—, ìµœì†Œ ì´ë™íšŸìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ê¸°ì— BFSë¡œ ì±„íƒ
- 1ì°¨ ë°°ì—´(`int[]`)ë¡œ í¬ì¸íŠ¸ë§Œ ì¡ì•„ì„œ ì´ë™í•˜ë ¤ê³  í–ˆìœ¼ë‚˜, ë°©ë¬¸ìœ ë¬´ì—ì„œ ë¬¸ì œê°€ ë‚˜íƒ€ë‚¨.
  - ë°©ë¬¸ìœ ë¬´ë¥¼ ì•Œ ìˆ˜ ìˆì„ë¼ë©´ ê²°êµ­ 2ì°¨ ë°°ì—´ì´ í•„ìš”
  - ë°©ë¬¸ìœ ë¬´ ëŒ€ì‹ , ë°©ë¬¸ì‹œ ì´ë™íšŸìˆ˜ë¡œ ê¸°ë¡(`int[][] visited`) 
  - `visited` í¬ê¸° `N X N` (1 â‰¤ N â‰¤ 500)
- ìƒëŒ€ë°© ë§ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ì´íŠ¸ì— ë„ì°©í–ˆì„ ê²½ìš°ë¡œ íƒìƒ‰í• ìˆ˜ë„ ìˆê³ , ë‚˜ì´íŠ¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ë°© ë§ì„ íƒìƒ‰í•  ìˆ˜ë„ ìˆì—ˆì§€ë§Œ, ë§ì˜ ê°¯ìˆ˜ê°€ ìµœëŒ€(1 â‰¤ M â‰¤ 1,000)
  - ì¦‰, ë°©ë¬¸ìœ ë¬´ë¥¼ íŒŒì•…í•˜ëŠ” 2ì°¨ë°°ì—´ì´ ìµœëŒ€ 1000ë²ˆê¹Œì§€ ê³„ì† ë§Œë“¤ì–´ì•¼ í•¨.
  - ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ëœ°ê±° ê°™ìŒ...(í•´ë³´ì§„ì•ŠìŒ)
  - ì¦‰, ë‚˜ì´íŠ¸ì—ì„œ ì°¾ëŠ” ìƒëŒ€ ë§ì„ íƒìƒ‰í•˜ëŠ” ê²ƒì„ íƒí•¨.

- íƒìƒ‰ë°©ë²•ì€, ë¯¸ë¦¬ `visited` ì¢Œí‘œì— -1ë¡œ ì°ì–´ë‘ .
  - ê·¸ë¦¬ê³  íƒìƒ‰í•˜ë©´ì„œ `-1`ì´ ë³´ì¼ ë•Œë§ˆë‹¤ ê°¯ìˆ˜ë¥¼ ì…ˆ. 
  - ì„¸ëŠ” ê°¯ìˆ˜ê°€ ë§ì˜ ê°¯ìˆ˜(`M`)ì´ ë„ë‹¬í•˜ë©´ íƒìƒ‰ì„ ì¢…ë£Œ 

- ì¶œë ¥
  - ìƒëŒ€ ë§ì˜ ì¢Œí‘œë§Œ ë‹´ëŠ” ë°°ì—´ì„ ë§Œë“¬.
  - `vistied` ì—ì„œ ì¢Œí‘œì— í•´ë‹¹í•˜ëŠ” ê°’ì„ ì¶”ì¶œí•˜ì—¬ ì¶œë ¥!

### ì½”ë“œ
```java
package Beakjoon.sliver;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class WiseKnight {
    static int N;
    static int M;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        int[][] visited = new int[N][N];

        int[] night = new int[2]; // ìŠ¤íƒ€íŠ¸ ì§€ì 
        st = new StringTokenizer(br.readLine());
        night[0] = Integer.parseInt(st.nextToken())-1;
        night[1] = Integer.parseInt(st.nextToken())-1;


        int[][] phone = new int[M][2];
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            phone[i][0] = Integer.parseInt(st.nextToken()) - 1;
            phone[i][1] = Integer.parseInt(st.nextToken()) - 1;
            visited[phone[i][0]][phone[i][1]] = -1;
        }

        BFS(visited, night);


        StringBuffer sb = new StringBuffer();
        int x = 0;
        int y = 0;
        for (int[] target : phone) {
            x = target[0];
            y = target[1];
            sb.append(visited[x][y]).append(" ");
        }
        System.out.println(sb);
        br.close();
    }

    private static void BFS(int[][] visited, int[] start) {
        Queue<int[]> queue = new LinkedList<>();
        queue.add(start);
        visited[start[0]][start[1]] = 0;
        int cnt = 0;
        while (!queue.isEmpty()) {
            int currentX = queue.peek()[0];
            int currentY = queue.peek()[1];
            queue.poll();

            //ë‚˜ì´íŠ¸ ì›€ì§ì„
            int[] dx = {-2, -2, -1, -1, 1, 1, 2, 2};
            int[] dy = {-1, 1, -2, 2, -2, 2, -1, 1};

            for (int i = 0; i < 8; i++) {
                int updateX = currentX + dx[i];
                int updateY = currentY + dy[i];

                if ((0 > updateX || N <= updateX) || (0 > updateY || N <= updateY)) continue;
                // ë°©ë¬¸í–ˆëŠ”ì§€ í™•ì¸
                if (visited[updateX][updateY] > 0) continue;
                if (visited[updateX][updateY] == -1) {
                    cnt++;
                }
                visited[updateX][updateY] = visited[currentX][currentY] + 1;
                if (cnt == M) {
                    return;
                }
                queue.add(new int[]{updateX, updateY});
            }
        }
    }
}

```
<img src ="https://user-images.githubusercontent.com/104331549/186869043-6c11a91c-d482-4881-a290-0b65deb9166f.png">