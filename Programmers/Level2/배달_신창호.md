
# ë¬¸ì œ êµ¬ì„± ğŸ“–
> ì½”ë”©í…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸ : í”„ë¡œê·¸ë˜ë¨¸ìŠ¤  
> ë‚œì´ë„ : 2ë‹¨ê³„    
> í’€ì´ ë‚ ì§œ : 2022.09.22  
> ì‚¬ìš©í•œ í’€ì´ ë°©ë²• : ë‹¤ìµìŠ¤íŠ¸ë¼   
> ì†Œìš”ì‹œê°„ : ê°œë…ì •ë¦¬
## ë¬¸ì œë§í¬
https://school.programmers.co.kr/learn/courses/30/lessons/12978

<br></br>
<br></br>


## ì‚½ì§ˆì½”ë”©
### í’€ì´
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í’€ì—ˆë‹¤.
- ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•œ ì„¤ëª…ì€ [ì—¬ê¸° ë§í¬ ì°¸ì¡°](https://github.com/Gloom-shin/algorithm-study/blob/gloom/Algorithm/Dijkstra(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC)%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)

### ì½”ë“œ
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {
    static int[] distance;
    static int n = 0;
    
    public int solution(int N, int[][] road, int K) {n = N + 2;
        distance = new int[n];
        //ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°,
        ArrayList<Node>[] adjList = new ArrayList[n]; // ë…¸ë“œ ê°¯ìˆ˜ + 1ë§Œí¼ ë°°ì—´ì„ ë§Œë“ ë‹¤.

        for (int i = 0; i < n; i++) {
            adjList[i] = new ArrayList<>(); // ë°°ì—´ ë‚´ë¶€, ArrayListë¡œ ì´ˆê¸°í™”
        }

        for (int[] r : road) {
            Node node1 = new Node(r[1], r[2]);
            Node node2 = new Node(r[0], r[2]);

            adjList[r[0]].add(node1); // ì–‘ë°©í–¥ì´ê¸°ì—
            adjList[r[1]].add(node2); // ì–‘ë°©í–¥ì´ê¸°ì—
        }
        dijkstra(1, adjList);
        int answer = 0;
        for (int i = 1; i < n; i++) {
            if (distance[i] <= K) {
                answer++;
            }
        }
        return answer;
    }
    public static void dijkstra(int start, ArrayList<Node>[] adjList) {
        boolean[] visited = new boolean[n]; // ë°©ë¬¸ ë…¸ë“œ ì²´í¬
        int INF = 123456;
        Arrays.fill(distance, INF); // ë°°ì—´ ì´ˆê¸°í™”
        distance[start] = 0; // ì‹œì‘ì§€ì  0;

        PriorityQueue<Node> priorityQueue = new PriorityQueue();
        priorityQueue.offer(new Node(start, 0)); // ì‹œì‘ì  ë„£ì–´ì£¼ê¸°

        while (!priorityQueue.isEmpty()) {
            //í˜„ì¬ ì§€ì  ì¶”ì¶œ
            int current = priorityQueue.poll().getEnd();

            //ë°©ë¬¸í–ˆë˜ê³³ ì œì™¸ ë¡œì§
            if (visited[current]) continue;
            visited[current] = true;

            for (Node next : adjList[current]) { // í˜„ì¬ ë…¸ë“œì—ì„œ ë‹¤ìŒ ë…¸ë“œë¡œ ê°ˆìˆ˜ ìˆëŠ” ê³³ í•œë²ˆì”© í›ì–´ë³´ê¸°
                if (distance[next.getEnd()] > distance[current] + next.distance) { //ì í˜€ìˆëŠ” ìµœë‹¨ê±°ë¦¬ë³´ë‹¤, ìƒˆë¡œ íƒìƒ‰í•œ ê³³ì˜ ê±°ë¦¬ë¹„ìš©ì´ ë” ì‘ë‹¤ë©´
                    distance[next.getEnd()] = distance[current] + next.distance;
                    priorityQueue.offer(new Node(next.getEnd(), distance[next.getEnd()]));
                }
            }
        }
    }
}
class Node implements Comparable<Node> {
    int end;
    int distance;

    public Node(int end, int cost) {
        this.end = end;
        this.distance = cost;
    }

    public int getEnd() {
        return end;
    }

    public int getCost() {
        return distance;
    }

    @Override
    public int compareTo(Node o) {
        return this.distance - o.distance;
    }
}
```

<img src="https://user-images.githubusercontent.com/104331549/191739959-f21f89df-973e-42a4-b8fa-abbf4c2650da.png">

### ë¬¸ì œ ì›ì¸
- ë§ˆì„ê°„ ê°„ì„  ë¹„ìš©ì´ ` 1 ì´ìƒ 500,000 ì´í•˜ì…ë‹ˆë‹¤.` ë¡œ ì¡°ê±´ì´ ì£¼ì–´ì¡Œì§€ë§Œ, ë‚˜ëŠ” `INF` ê°’ ëŒ€ì‹  `123456`ì˜ ê°’ì„ ë„£ì—ˆë”ë‹ˆ, ì‹¤íŒ¨ í˜„ìƒì´ ì¼ì–´ë‚¬ë‹¤.
- ê·¸ë˜ì„œ `INF`ê°’ì„ `500001`ë¡œ í•´ì£¼ë‹ˆê¹Œ í•´ê²°ë˜ì—ˆë‹¤.


<img src="https://user-images.githubusercontent.com/104331549/191740203-a0bd3c7a-06b3-4884-99e0-58a60359406f.png">