# ë¬¸ì œ êµ¬ì„± ğŸ“–
> ì½”ë”©í…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸ : í”„ë¡œê·¸ë˜ë¨¸ìŠ¤  
> ë‚œì´ë„ : 3ë‹¨ê³„    
> í’€ì´ ë‚ ì§œ : 2022.12.15  
> ë¶„ë¥˜ : Graph, ìœ„ìƒ ì •ë ¬  
> ì†Œìš”ì‹œê°„ : ê°œë…ì •ë¦¬


## ë¬¸ì œë§í¬
https://school.programmers.co.kr/learn/courses/30/lessons/49189
<br></br>
<br></br>

###  ê°œë… ì •ë¦¬ 
 - [ìœ„ìƒì •ë ¬](https://github.com/Gloom-shin/algorithm-study/blob/main/Algorithm/TopologicalSort(%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC).md)

## ë¬¸ì œ í’€ì´
### ì„¸íŒ…
1. ì£¼ì–´ì§€ëŠ” edgeë°°ì—´ì„ ì‘ì€ ìˆ˜ ë…¸ë“œë¶€í„° ì •ë ¬í•œë‹¤. 
2. ê° ë…¸ë“œë³„ë¡œ ê±°ë¦¬ë¥¼ ì´ ìˆ˜ ìˆëŠ” ë°°ì—´ì„ ë§Œë“ ë‹¤.
3. ê° ë…¸ë“œë³„ë¡œ ì—°ê²°ëœ ê°„ì„ ì„ ë‹´ì„ ìˆ˜ ìˆëŠ” ì»¬ë ‰ì…˜ì„ ë§Œë“ ë‹¤. 
4. ìœ„ìƒì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì„ ìœ„í•œ Queue ìë£Œêµ¬ì¡°ë¥¼ ë§Œë“ ë‹¤.

### êµ¬í˜„
1. ê°„ì„ ì´ ì–‘ë°©í–¥ì´ê¸° ë•Œë¬¸ì—, ì–‘ë°©í–¥ìœ¼ë¡œ Graphì— ë„£ëŠ”ë‹¤. 
2. ê·¸ë¦¬ê³  ì‹œì‘ì€ 1ë²ˆ ë…¸ë“œê°€ ê¸°ì¤€ì„ìœ¼ë¡œ Queueì— 1ì„ ë„£ì–´ì¤€ë‹¤.
3. Queueì—ì„œ ì¸ì ‘ë…¸ë“œë¥¼ í™•ì¸í•˜ë©°, 1ë²ˆìœ¼ë¡œ ë¶€í„° ê±°ë¦¬ë¥¼ í™•ì¸í•˜ì§€ ëª»í•œ ë…¸ë“œë¼ë©´ +1ì„ í•´ì£¼ê³  Queueì— ì¶”ê°€
4. ìœ„ ê³¼ì •ì„ Queueê°€ ë¹Œë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤. 

## ì½”ë“œ
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] edge) {
                int answer = 0;
        int[] route = new int[n+1];
        Arrays.sort(edge, (o1, o2) -> {
            return o1[0] - o2[0];
        });
        Queue<Integer> queue = new LinkedList<>();
        ArrayList<Integer>[] graph = new ArrayList[n+1];

        for (int i = 1; i < graph.length; i++) {
            graph[i] = new ArrayList<Integer>();
        }
        for (int[] node: edge) {
            graph[(node[0])].add(node[1]);
            graph[(node[1])].add(node[0]);
        }

        queue.offer(1);
        route[1] = 1;

        while (!queue.isEmpty()){
            Integer node = queue.poll();
            for (int next:graph[node]) {
                if(route[next] == 0){
                    queue.offer(next);
                    route[next] = route[node] +1;
                }
            }
        }
        int max = Arrays.stream(route).max().orElseThrow();
        for (int r:route) {
            if (max == r)
                answer++;
        }
        return answer;
    }
    
}
```